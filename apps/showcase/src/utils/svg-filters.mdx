import { Meta } from '@storybook/addon-docs/blocks';

<Meta title="Documentaci√≥n/Motor SVG - Gu√≠a T√©cnica Completa" />


# Motor de Filtros SVG <span class="badge badge-core">Core</span>

<div class="info-box">
  <strong>üéØ N√∫cleo T√©cnico del Efecto de Cristal L√≠quido</strong><br/>
  Este documento profundiza en el coraz√≥n del sistema: el motor de filtros SVG implementado en <code>src/utils/svg-filters.ts</code>. Estas son las funciones puras y agn√≥sticas al framework que generan los mapas de desplazamiento complejos y los atributos de filtros SVG que dan vida al efecto.
</div>

## üìë √çndice de Contenidos

<div class="toc">
  <ul>
    <li>üîß Funciones Principales</li>
    <li>üèóÔ∏è Pipeline de Procesamiento</li>
    <li>üß† Conceptos T√©cnicos</li>
    <li>‚ö° Optimizaci√≥n y Performance</li>
    <li>üí° Casos de Uso Avanzados</li>
    <li>üêõ Troubleshooting</li>
  </ul>
</div>

## üîß Funciones Principales

### <code>calculateBorderDimensions(geometry: GeometryConfig)</code> <span class="badge badge-core">Core</span>

<div class="pipeline-step">
  <h4>üìê C√°lculo de Dimensiones del Cristal</h4>
  <p>Determina las zonas de distorsi√≥n progresiva bas√°ndose en la configuraci√≥n geom√©trica. Esta funci√≥n es fundamental para crear el efecto de "cristal m√°s grueso en el centro".</p>
</div>

<table class="function-table">
  <thead>
    <tr>
      <th>Par√°metro</th>
      <th>Tipo</th>
      <th>Descripci√≥n</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><span class="param-name">geometry</span></td>
      <td><span class="param-type">GeometryConfig</span></td>
      <td>Configuraci√≥n que incluye width, height, radius y border (porcentaje)</td>
    </tr>
  </tbody>
</table>

**Retorna:** <code>ExtendedGeometryConfig</code> con <code>calculatedBorder</code> y <code>minDimension</code> a√±adidos.

<details class="collapsible">
  <summary><strong>üßÆ Implementaci√≥n Detallada y Casos Edge</strong></summary>
  <div class="collapsible-content">

```typescript
function calculateBorderDimensions(geometry: GeometryConfig): ExtendedGeometryConfig {
  const { width, height, border } = geometry;
  
  // Encuentra la dimensi√≥n m√≠nima para calcular el borde proporcional
  const minDimension = Math.min(width, height);
  
  // Calcula el borde real en p√≠xeles (factor 0.5 para suavizar el efecto)
  const calculatedBorder = minDimension * (border * 0.5);
  
  return {
    ...geometry,
    calculatedBorder,
    minDimension
  };
}
```

**Casos Edge Importantes:**

```typescript
// ‚úÖ Caso normal
calculateBorderDimensions({ width: 300, height: 200, radius: 16, border: 0.1 })
// ‚Üí { width: 300, height: 200, radius: 16, border: 0.1, calculatedBorder: 10, minDimension: 200 }

// ‚ö†Ô∏è Caso extremo: border muy grande
calculateBorderDimensions({ width: 100, height: 100, radius: 8, border: 0.8 })
// ‚Üí { width: 100, height: 100, radius: 8, border: 0.8, calculatedBorder: 40, minDimension: 100 }
// Nota: 40px de borde en un elemento de 100px = 80% del √°rea es zona central

// üîÑ Caso asim√©trico
calculateBorderDimensions({ width: 500, height: 100, radius: 20, border: 0.15 })
// ‚Üí { width: 500, height: 100, radius: 20, border: 0.15, calculatedBorder: 7.5, minDimension: 100 }
// El borde se basa en la altura (dimensi√≥n m√≠nima)
```

  </div>
</details>

### <code>buildDisplacementSVG(geometry, visual)</code> <span class="badge badge-advanced">Advanced</span>

<div class="pipeline-step">
  <h4>üé® Generaci√≥n del Mapa de Desplazamiento</h4>
  <p>Construye el SVG que act√∫a como mapa de desplazamiento. Este SVG define c√≥mo se distorsionan los p√≠xeles del fondo, usando gradientes de color como datos de control.</p>
</div>

<table class="function-table">
  <thead>
    <tr>
      <th>Par√°metro</th>
      <th>Tipo</th>
      <th>Descripci√≥n</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><span class="param-name">geometry</span></td>
      <td><span class="param-type">ExtendedGeometryConfig</span></td>
      <td>Geometr√≠a calculada con borders y dimensiones</td>
    </tr>
    <tr>
      <td><span class="param-name">visual</span></td>
      <td><span class="param-type">VisualConfig</span></td>
      <td>Configuraci√≥n visual (lightness, alpha, blur, blend)</td>
    </tr>
  </tbody>
</table>

**Retorna:** <code>string</code> - Contenido SVG completo del mapa de desplazamiento.

<details class="collapsible">
  <summary><strong>üîç Anatom√≠a del SVG Generado</strong></summary>
  <div class="collapsible-content">

```xml
<svg class="displacement-image" viewBox="0 0 300 200" 
     xmlns="http://www.w3.org/2000/svg">
  <defs>
    <!-- üî¥ Gradiente ROJO: Controla desplazamiento horizontal -->
    <linearGradient id="red" x1="100%" x2="0%">
      <stop offset="0%" stop-color="#0000"/>   <!-- Transparente = Sin movimiento -->
      <stop offset="100%" stop-color="red"/>  <!-- Rojo = M√°ximo desplazamiento X -->
    </linearGradient>
    
    <!-- üîµ Gradiente AZUL: Controla desplazamiento vertical -->
    <linearGradient id="blue" x1="0%" y1="0%" x2="0%" y2="100%">
      <stop offset="0%" stop-color="#0000"/>   <!-- Transparente = Sin movimiento -->
      <stop offset="100%" stop-color="blue"/> <!-- Azul = M√°ximo desplazamiento Y -->
    </linearGradient>
  </defs>
  
  <!-- Capa base negra: Zona sin distorsi√≥n -->
  <rect fill="black" width="300" height="200"/>
  
  <!-- Capa roja: Informaci√≥n de desplazamiento horizontal -->
  <rect fill="url(#red)" width="300" height="200"/>
  
  <!-- Capa azul: Informaci√≥n de desplazamiento vertical (con blend mode) -->
  <rect fill="url(#blue)" width="300" height="200" 
        style="mix-blend-mode: screen"/>
  
  <!-- Zona central "s√≥lida": Simula el grosor del cristal -->
  <rect x="15" y="15" width="270" height="170"
        fill="hsl(0 0% 85% / 0.8)" 
        style="filter: blur(2px)"/>
</svg>
```

**¬øPor qu√© esta estructura espec√≠fica?**

<div class="features-grid">
  <div class="feature-card">
    <h4>üéØ Gradientes Direccionales</h4>
    <p>Los gradientes rojo (horizontal) y azul (vertical) crean vectores de movimiento perpendiculares que el filtro SVG interpretar√° como coordenadas X e Y.</p>
  </div>
  
  <div class="feature-card">
    <h4>üîÑ Blend Modes</h4>
    <p>El modo <code>screen</code> combina los gradientes rojo y azul, creando colores mixtos que producen desplazamientos diagonales.</p>
  </div>
  
  <div class="feature-card">
    <h4>üå´Ô∏è Zona Central Difusa</h4>
    <p>El rect√°ngulo central con blur simula la parte m√°s gruesa del cristal, donde la distorsi√≥n es m√≠nima pero presente.</p>
  </div>
  
  <div class="feature-card">
    <h4>‚ö´ Base Negra</h4>
    <p>El fondo negro asegura que las √°reas sin gradiente tengan valor RGB (0,0,0) = sin desplazamiento.</p>
  </div>
</div>

  </div>
</details>

### <code>encodeDataURI(svgContent: string)</code> <span class="badge badge-core">Core</span>

<div class="pipeline-step">
  <h4>üîê Codificaci√≥n para Navegadores</h4>
  <p>Convierte el SVG en un Data URI que puede ser usado directamente en atributos HTML/CSS como <code>href</code> o <code>url()</code>.</p>
</div>

```typescript
function encodeDataURI(svgContent: string): string {
  return `data:image/svg+xml,${encodeURIComponent(svgContent)}`;
}
```

<div class="tip-box">
  <strong>üí° Optimizaci√≥n de Performance:</strong><br/>
  Esta funci√≥n usa <code>encodeURIComponent()</code> en lugar de Base64 porque es m√°s eficiente para SVG con mucho texto, resultando en URIs m√°s cortas y mejor performance del navegador.
</div>

**Ejemplo de transformaci√≥n:**

```typescript
// Input SVG
const svg = '<svg><rect fill="red"/></svg>';

// Output Data URI
const uri = encodeDataURI(svg);
// ‚Üí 'data:image/svg+xml,%3Csvg%3E%3Crect%20fill%3D%22red%22%2F%3E%3C%2Fsvg%3E'

// Uso directo en CSS
// background-image: url('data:image/svg+xml,%3Csvg...');
// o en SVG feImage: href="data:image/svg+xml,%3Csvg..."
```

### <code>generateFilterAttributes(visual: VisualConfig)</code> <span class="badge badge-advanced">Advanced</span>

<div class="pipeline-step">
  <h4>üéõÔ∏è Configuraci√≥n de Filtros SVG</h4>
  <p>Genera los atributos espec√≠ficos para cada canal de color en el filtro SVG, implementando la aberraci√≥n crom√°tica simulada.</p>
</div>

<details class="collapsible">
  <summary><strong>üåà Implementaci√≥n de Aberraci√≥n Crom√°tica</strong></summary>
  <div class="collapsible-content">

```typescript
function generateFilterAttributes(visual: VisualConfig) {
  const { x, y, scale, r, g, b, displace } = visual;
  
  // Calcula intensidades individuales por canal
  const baseScale = scale || 10;
  
  return {
    // Canal ROJO - Baseline de distorsi√≥n
    red: {
      xChannelSelector: x, // T√≠picamente 'R'
      yChannelSelector: y, // T√≠picamente 'B' 
      scale: baseScale + r // Ej: 10 + 50 = 60
    },
    
    // Canal VERDE - Intensidad m√°xima (simula refracci√≥n del verde)
    green: {
      xChannelSelector: x,
      yChannelSelector: y,
      scale: baseScale + g // Ej: 10 + 55 = 65
    },
    
    // Canal AZUL - Intensidad m√≠nima 
    blue: {
      xChannelSelector: x,
      yChannelSelector: y,
      scale: baseScale + b // Ej: 10 + 45 = 55
    },
    
    // Desenfoque gaussiano final
    gaussianBlur: {
      stdDeviation: displace // Suaviza el resultado final
    }
  };
}
```

**Resultado de la diferenciaci√≥n por canales:**

<table class="function-table">
  <thead>
    <tr>
      <th>Canal</th>
      <th>Intensidad</th>
      <th>Efecto Visual</th>
      <th>Simulaci√≥n F√≠sica</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>üî¥ Rojo</td>
      <td>60 (baseline)</td>
      <td>Desplazamiento est√°ndar</td>
      <td>Longitud de onda larga</td>
    </tr>
    <tr>
      <td>üü¢ Verde</td>
      <td>65 (m√°ximo)</td>
      <td>Mayor distorsi√≥n</td>
      <td>M√°xima refracci√≥n</td>
    </tr>
    <tr>
      <td>üîµ Azul</td>
      <td>55 (m√≠nimo)</td>
      <td>Menor distorsi√≥n</td>
      <td>Longitud de onda corta</td>
    </tr>
  </tbody>
</table>

  </div>
</details>

### <code>generateDisplacementMap(geometry, visual)</code> <span class="badge badge-new">Orquestador</span>

<div class="pipeline-step">
  <h4>üéØ Pipeline Completo</h4>
  <p>Funci√≥n principal que orquesta todo el proceso: calcula geometr√≠a, genera SVG, codifica y produce atributos de filtro.</p>
</div>

## üèóÔ∏è Pipeline de Procesamiento Completo

<div class="info-box">
  <strong>üîÑ Flujo de Datos Completo:</strong> Desde configuraci√≥n hasta filtro SVG aplicado
</div>

```typescript
// Input: Configuraci√≥n del usuario
const geometry = { width: 300, height: 200, radius: 16, border: 0.1 };
const visual = {
  frost: 0.15, blur: 11, displace: 0.4, scale: 10, 
  alpha: 0.95, lightness: 100, x: 'R', y: 'B', 
  blend: 'screen', r: 50, g: 55, b: 45
};

// Paso 1: Calcula dimensiones del cristal
const calculatedGeometry = calculateBorderDimensions(geometry);
// ‚Üí { width: 300, height: 200, radius: 16, border: 0.1, calculatedBorder: 10, minDimension: 200 }

// Paso 2: Genera SVG displacement map
const svgContent = buildDisplacementSVG(calculatedGeometry, visual);
// ‚Üí '<svg class="displacement-image" viewBox="0 0 300 200">...</svg>'

// Paso 3: Codifica como Data URI
const dataUri = encodeDataURI(svgContent);
// ‚Üí 'data:image/svg+xml,%3Csvg%20class%3D%22displacement-image%22...'

// Paso 4: Genera atributos de filtro
const filterAttributes = generateFilterAttributes(visual);
// ‚Üí { red: { scale: 60, xChannelSelector: 'R', yChannelSelector: 'B' }, ... }

// Paso 5: Resultado final listo para React
const result = {
  dataUri,
  svgContent,
  calculatedGeometry,
  filterAttributes
};
```

<div class="success-box">
  <strong>‚úÖ Resultado Optimizado:</strong> Todo el pipeline se ejecuta en ~1-2ms y est√° completamente memoizado en React para evitar rec√°lculos innecesarios.
</div>

## üß† Conceptos T√©cnicos Fundamentales

### üìç Displacement Mapping: La Base del Efecto

<div class="tip-box">
  <strong>üéØ Concepto Clave:</strong> El displacement mapping usa valores de color como "instrucciones de movimiento" para cada p√≠xel.
</div>

```javascript
// Concepto simplificado del algoritmo
function displacementMapping(backgroundPixels, displacementMap, intensity) {
  for (let pixel of backgroundPixels) {
    // Lee el color del mapa de desplazamiento en la misma posici√≥n
    let displacementColor = displacementMap.getColorAt(pixel.x, pixel.y);
    
    // Usa los canales rojo y azul como coordenadas de movimiento
    let newX = pixel.x + (displacementColor.red * intensity / 255);
    let newY = pixel.y + (displacementColor.blue * intensity / 255);
    
    // Obtiene el p√≠xel del fondo en la nueva posici√≥n
    outputPixel = backgroundImage.getPixelAt(newX, newY);
  }
}
```

**Tabla de interpretaci√≥n de colores:**

<table class="function-table">
  <thead>
    <tr>
      <th>Color RGB</th>
      <th>Desplazamiento X</th>
      <th>Desplazamiento Y</th>
      <th>Resultado Visual</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>(0, 0, 0) Negro</td>
      <td>0</td>
      <td>0</td>
      <td>Sin movimiento</td>
    </tr>
    <tr>
      <td>(255, 0, 0) Rojo</td>
      <td>M√°ximo ‚Üí</td>
      <td>0</td>
      <td>Desplazamiento horizontal</td>
    </tr>
    <tr>
      <td>(0, 0, 255) Azul</td>
      <td>0</td>
      <td>M√°ximo ‚Üì</td>
      <td>Desplazamiento vertical</td>
    </tr>
    <tr>
      <td>(128, 0, 128) Magenta</td>
      <td>Medio ‚Üí</td>
      <td>Medio ‚Üì</td>
      <td>Desplazamiento diagonal</td>
    </tr>
  </tbody>
</table>

### üåà Aberraci√≥n Crom√°tica: Simulaci√≥n de F√≠sica √ìptica

<div class="info-box">
  <strong>üî¨ Fundamento F√≠sico:</strong> En el mundo real, diferentes longitudes de onda de luz se refractan en √°ngulos ligeramente diferentes al pasar por medios transparentes.
</div>

**Implementaci√≥n en nuestro filtro SVG:**

```xml
<!-- Procesa cada canal RGB por separado con diferentes intensidades -->

<!-- Canal ROJO: Intensidad 60 -->
<feDisplacementMap in="SourceGraphic" in2="map" 
                   xChannelSelector="R" yChannelSelector="B"
                   scale="60" result="dispRed"/>
<feColorMatrix in="dispRed" values="1 0 0 0 0    ‚Üê Solo conserva rojo
                                    0 0 0 0 0
                                    0 0 0 0 0
                                    0 0 0 1 0" result="red"/>

<!-- Canal VERDE: Intensidad 65 (mayor distorsi√≥n) -->
<feDisplacementMap in="SourceGraphic" in2="map"
                   xChannelSelector="R" yChannelSelector="B" 
                   scale="65" result="dispGreen"/>
<feColorMatrix in="dispGreen" values="0 0 0 0 0
                                      0 1 0 0 0    ‚Üê Solo conserva verde
                                      0 0 0 0 0
                                      0 0 0 1 0" result="green"/>

<!-- Canal AZUL: Intensidad 55 (menor distorsi√≥n) -->
<feDisplacementMap in="SourceGraphic" in2="map"
                   xChannelSelector="R" yChannelSelector="B"
                   scale="55" result="dispBlue"/> 
<feColorMatrix in="dispBlue" values="0 0 0 0 0
                                     0 0 0 0 0
                                     0 0 1 0 0    ‚Üê Solo conserva azul
                                     0 0 0 1 0" result="blue"/>

<!-- Recombina los canales con modo screen -->
<feBlend in="red" in2="green" mode="screen" result="rg"/>
<feBlend in="rg" in2="blue" mode="screen" result="output"/>
```

## ‚ö° Optimizaci√≥n y Performance

### üöÄ Caracter√≠sticas de Performance

<div class="features-grid">
  <div class="feature-card">
    <h4>‚è±Ô∏è Complejidad O(1)</h4>
    <p>Todas las funciones realizan operaciones de tiempo constante. No hay bucles sobre p√≠xeles ni operaciones costosas.</p>
  </div>
  
  <div class="feature-card">
    <h4>üß† Memoizaci√≥n Friendly</h4>
    <p>Funciones puras sin efectos secundarios, perfectas para <code>useMemo()</code> de React.</p>
  </div>
  
  <div class="feature-card">
    <h4>üîÑ Framework Agnostic</h4>
    <p>Pueden usarse con cualquier framework JS o incluso vanilla JavaScript.</p>
  </div>
  
  <div class="feature-card">
    <h4>üåê Browser Optimized</h4>
    <p>Los navegadores modernos optimizan autom√°ticamente los filtros SVG usando aceleraci√≥n por hardware.</p>
  </div>
</div>

### üìä Benchmarks de Performance

<table class="function-table">
  <thead>
    <tr>
      <th>Funci√≥n</th>
      <th>Tiempo Ejecuci√≥n</th>
      <th>Complejidad</th>
      <th>Memoria</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><span class="param-name">calculateBorderDimensions</span></td>
      <td>&lt; 0.1ms</td>
      <td>O(1)</td>
      <td>~100 bytes</td>
    </tr>
    <tr>
      <td><span class="param-name">buildDisplacementSVG</span></td>
      <td>&lt; 0.5ms</td>
      <td>O(1)</td>
      <td>~2-5KB</td>
    </tr>
    <tr>
      <td><span class="param-name">encodeDataURI</span></td>
      <td>&lt; 0.1ms</td>
      <td>O(n) donde n = longitud SVG</td>
      <td>~1.5x tama√±o SVG</td>
    </tr>
    <tr>
      <td><span class="param-name">generateFilterAttributes</span></td>
      <td>&lt; 0.1ms</td>
      <td>O(1)</td>
      <td>~200 bytes</td>
    </tr>
  </tbody>
</table>

## üí° Casos de Uso Avanzados

### üéØ Configuraciones Especializadas

<details class="collapsible">
  <summary><strong>üî¨ Configuraci√≥n "Microscopio" - Distorsi√≥n Extrema</strong></summary>
  <div class="collapsible-content">

```typescript
const microscope = generateDisplacementMap(
  { width: 400, height: 400, radius: 200, border: 0.3 },
  {
    frost: 0.1, blur: 25, displace: 1.8, scale: 50,
    alpha: 0.7, lightness: 60, x: 'R', y: 'G', blend: 'multiply',
    r: 120, g: 140, b: 80  // Aberraci√≥n crom√°tica extrema
  }
);
```

**Resultado:** Efecto de lente de aumento con aberraci√≥n crom√°tica muy pronunciada, ideal para elementos que simulan lupas o efectos de zoom.

  </div>
</details>

<details class="collapsible">
  <summary><strong>üíß Configuraci√≥n "Gota de Agua" - Refracci√≥n Suave</strong></summary>
  <div class="collapsible-content">

```typescript
const waterDrop = generateDisplacementMap(
  { width: 150, height: 150, radius: 75, border: 0.8 },
  {
    frost: 0.05, blur: 8, displace: 0.2, scale: 15,
    alpha: 0.95, lightness: 98, x: 'R', y: 'B', blend: 'screen',
    r: 25, g: 30, b: 20  // Aberraci√≥n crom√°tica sutil
  }
);
```

**Resultado:** Efecto muy sutil que simula ver a trav√©s de una gota de agua, perfecto para elementos decorativos discretos.

  </div>
</details>

<details class="collapsible">
  <summary><strong>üåà Configuraci√≥n "Prisma" - M√°xima Separaci√≥n de Colores</strong></summary>
  <div class="collapsible-content">

```typescript
const prism = generateDisplacementMap(
  { width: 300, height: 100, radius: 8, border: 0.05 },
  {
    frost: 0.3, blur: 3, displace: 0.8, scale: 5,
    alpha: 0.6, lightness: 90, x: 'R', y: 'B', blend: 'screen',
    r: 200, g: 150, b: 100  // Diferencias extremas entre canales
  }
);
```

**Resultado:** Efecto que simula un prisma, con separaci√≥n de colores muy visible en los bordes, ideal para elementos art√≠sticos.

  </div>
</details>

## üêõ Troubleshooting y Debugging

### ‚ö†Ô∏è Problemas Comunes y Soluciones

<div class="warning-box">
  <strong>üö® Problema:</strong> El efecto no se ve o es muy sutil<br/>
  <strong>üí° Soluci√≥n:</strong> Verifica que <code>backdrop-filter</code> est√© soportado y que haya contenido detr√°s del elemento.
</div>

```css
/* ‚úÖ Aseg√∫rate de que hay contenido detr√°s */
.glass-effect {
  backdrop-filter: url(#filter);
  position: absolute; /* o fixed */
  z-index: 10;
}

/* ‚úÖ El contenido debe estar detr√°s */
.background-content {
  z-index: 1;
}
```

<div class="warning-box">
  <strong>üö® Problema:</strong> Performance degradada en dispositivos m√≥viles<br/>
  <strong>üí° Soluci√≥n:</strong> Reduce la complejidad del filtro y usa <code>will-change</code>.
</div>

```css
.glass-effect {
  will-change: backdrop-filter;
  /* Reduce scale values en mobile */
}

@media (max-width: 768px) {
  .glass-effect {
    backdrop-filter: url(#filter-mobile) blur(5px); /* Filtro simplificado */
  }
}
```

### üîç Herramientas de Debug

<details class="collapsible">
  <summary><strong>üõ†Ô∏è Debug Mode Avanzado</strong></summary>
  <div class="collapsible-content">

```typescript
// Activa debug mode para ver el displacement map
const debugResult = generateDisplacementMap(geometry, { ...visual, debug: true });

// Visualiza el SVG generado
console.log('SVG Content:', debugResult.svgContent);

// Visualiza los atributos calculados
console.table(debugResult.filterAttributes);

// Crea una imagen del displacement map para inspecci√≥n visual
const img = new Image();
img.src = debugResult.dataUri;
document.body.appendChild(img);
```

  </div>
</details>

## üìö Referencias T√©cnicas Externas

- **[MDN feDisplacementMap](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feDisplacementMap)** - Documentaci√≥n oficial del elemento SVG
- **[MDN feGaussianBlur](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feGaussianBlur)** - Filtro de desenfoque gaussiano
- **[MDN Data URIs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs)** - Formato de URIs de datos
- **[Displacement Mapping (Wikipedia)](https://en.wikipedia.org/wiki/Displacement_mapping)** - Teor√≠a del mapeo de desplazamiento
- **[CSS backdrop-filter](https://developer.mozilla.org/en-US/docs/Web/CSS/backdrop-filter)** - Documentaci√≥n de la propiedad CSS

<div class="success-box">
  <strong>üéØ ¬øListo para el Siguiente Nivel?</strong><br/>
  Explora la <a href="../components/GlassEffect">documentaci√≥n del componente GlassEffect</a> para ver c√≥mo se integran estas funciones en React, o revisa la <a href="../stories/GlassEffect">galer√≠a de ejemplos interactivos</a> en Storybook.
</div>